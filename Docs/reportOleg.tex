\documentclass[12pt]{article}
\usepackage{indentfirst}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{listings}
\usepackage{color}
\begin{document}
\begin{titlepage}
	\begin{center}
		\bfseries
		
		{\Large Московский авиационный институт\\ (национальный исследовательский университет)
			
		}
		
		\vspace{48pt}
		
		{\large Факультет информационных технологий и прикладной математики
		}
		
		\vspace{36pt}
		
		
		{\large Кафедра вычислительной математики и~программирования
			
		}
		
		
		\vspace{48pt}
		
		Курсовая работа по курсу <<Дискрeтный анализ>>: Методы сжатия данных
	\end{center}
	
	\vspace{72pt}
	
	\begin{flushright}
		\begin{tabular}{rl}
			Студент: & О.\,Р. Лисовский  \\
			Преподаватель: & Н.\,А. Зацепин \\
			Группа: & М8О-408Б \\
			Дата: & \\
			Оценка: & \\
			Подпись: & \\{\tiny {\tiny }}
		\end{tabular}
	\end{flushright}
	
	\vfill
	
	\begin{center}
		\bfseries
		Москва, \the\year
	\end{center}
\end{titlepage}

\pagebreak

\subsection*{Условие}

Необходимо реализовать два известных метода сжатия данных для сжатия одного файла. 

Формат запуска должен быть аналогичен формату запуска программы gzip, должны быть поддержаны следующие ключи: -c, -d, -k, -l, -r, -t -1 -9. Должно поддерживаться указание символа дефиса в качестве стандартного ввода.

\subsection*{Метод решения}

Как и требуется в условии запуск программы аналогичен запуску утилиты gzip: ./main <ключи> <файлы> <ключи> <файлы> ...

\subsubsection*{Обработка входных данных}

Программа начинается с обработки строки стандартного ввода. Строка обрабатывается по словам. Если слово начинается с символа <<->>, то предполагается что это набор ключей и ключи передаются в специальную функцию, чтобы исключить противоречия работы ключей. Возможные сочетания и главенство одних ключей над другими описано в таблице ниже.

\noindent
\begin{tabular}{| c | c | c | c | c | c | c | c |}
	\hline
  & d     & k           & l           & r     & t           & 1           & 9           \\
  \hline
c & нет   & c блокирует & l блокирует & нет   & t блокирует & нет         & нет         \\
  & блока & k           & c           & блока & c           & блока       & блока       \\
  \hline
d & -     & нет         & l блокирует & нет   & t блокирует & d блокирует & d блокирует \\
  &       & блока       & d           & блока & d           & 1           & 9           \\
  \hline
k & -     & -           & l блокирует & нет   & t блокирует & нет         & нет         \\
  &       &             & k           & блока & k           & блока       & блока       \\
  \hline
l & -     & -           & -           & нет   & l блокирует & l блокирует & l блокирует \\
  &       &             &             & блока & t           & 1           & 9           \\
  \hline
r & -     & -           & -           & -     & нет         & нет         & нет         \\
  &       &             &             &       & блока       & блока       & блока       \\
  \hline
t & -     & -           & -           & -     & -           & t блокирует & t блокирует \\
  &       &             &             &       &             & 1           & 9           \\
  \hline
  &       &             &             &       &             &             & последний   \\
1 & -     & -           & -           & -     & -           & -           & полученный  \\
  &       &             &             &       &             &             & блокирует   \\
  &       &             &             &       &             &             & прошлые     \\
  \hline
\end{tabular}

В случае если полученное слово начинается с другого символа, то программа предполагает что это имя файла или директории и добавляет его в список для дальнейшей обработки.

\subsubsection*{Интерфейс}

После установления активных ключей и заполнения списка объектов компрессии/декомпрессии, программа начинает работу  этим самым списком. В случае отсутствия ключа -r все директории не рассматриваются. При активации ключа всё содержимое директории рекурсивно обрабатывается программой. При работе с файлами проверяется наличие/отсутствие (в зависимости от ключа -d) файла с расширением .gz и в случае необходимости программа спрашивает у пользователя право на перезапись соответствующего файла.

При подготовке непосредственно компрессии проверяется наличие ключа -1 или -9 для определения необходимого алгоритма. В случае их отсутствия используются оба алгоритма и выбирается лучший результат.

При подготовке непосредственно декомпрессии читается первый байт файла для установления алгоритма декодирования.

\subsubsection*{Постобработка}

При окончании работы компрессии/декомпрессии программа получает сигнал об их завершении. Если этот сигнал соответствует ошибке то работа с конкретным файлом аварийно прекращается и обрабатывается следующий файл. Дальнейшие действия обусловлены введёнными ключами.

Далее незакодированный файл будет упоминаться как файл, а закодированный файл как архив.


\subsubsection*{Арифметическая компрессия}

В данной курсовой работе реализована целочисленная компрессия, так как реализовать компрессию на числах с плавающей точкой крайне проблематично в силу ограничений. Например, тот же машинный эпсилон или точность в целом. Целочисленная компрессия довольно неплохо отличается от арифметики с плавающей точкой, однако ниже будет описано всё наиболее подробно.

В первую очередь настраивается таблица частот для последующей работы и кодировки символов. Частоты символов выставляются на единицы, чтобы накопленные частоты высчитывались правильно. В соответствии с ними выставляются и накопленные частоты. Они необходимы для определения отрезков, которые как раз отвечают за кодировку символов.

После этого открывается новый временный файл, куда заносится тип кодировки и размер исходного файла. Задаются стартовые значения для счётчиков и инициализируется буфер. 

Далее начинается кодировка символов. В соответствии каждому символу выставляется нужный отрезок. Цель заключается в том, чтобы записать старшие биты, по которым будет достаточно определить отрезок, в файл. Проводятся некоторые манипуляции с отрезком, благодаря которым можно записать нужные старшие биты. После кодирования символа отрезок остаётся тем же, и продолжаем кодировать при помощи него и следующие символы.

После кодирования символов обновляется и оптимизируется таблица частот.

После кодирования символов мы кодируем EOF и дописываем недостающие биты. Завершаем работу с файлом.

\subsubsection*{Арифметическая декомпрессия}

Производится подготовка таблицы частот, аналогично компрессии.

На вход поступает сжатый файл, в котором закодировано число. Мы заносим в наш буфер первые 16 бит. Самые старшие из них по сути и дают нам информацию об отрезке, а следовательно и символе. После определения символа мы проводим аналогичные манипуляции с отрезком, как и в случае с компрессией, отбрасывая уже ненужные биты и загружая новые.

После этого также обновляется и оптимизируется таблица частот. Оптимизация в первую очередь нужна именно во время декомпрессии. Она заключается в том, чтобы наиболее часто встречающиеся символы оказывались ближе к началу таблицы частот. Это ускоряет поиск, а значит и распаковку.

\subsubsection*{LZ77 компрессия}

LZ77 использует уже просмотренную часть сообщения как словарь. Чтобы добиться сжатия, он пытается заменить очередной фрагмент сообщения на указатель в содержимое словаря.

В качестве модели данных LZ77 использует “скользящее” по сообщению окно, разделенное на две неравные части. Первая, большая по размеру, включает уже просмотренную часть сообщения и называется словарём. Вторая, намного меньшая, является буфером, содержащим еще не закодированные символы входного потока. Обычно размер окна составляет несколько килобайтов. Буфер намного меньше, обычно не более ста байтов. Алгоритм пытается найти в словаре фрагмент, совпадающий с содержимым буфера.

Алгоритм LZ77 выдает коды, состоящие из трех элементов:<offset,length,symbol>

\begin{enumerate}
	\item offset - смещение в словаре относительно его начала подстроки, совпадающей с содержимым буфера;
	\item length - длина подстроки;
	\item symbol - первый символ в буфере, следующий за подстрокой.
\end{enumerate}

Если совпадение не обнаружено, то алгоритм выдает код <0, 0, первый символ в буфере> и продолжает свою работу. Хотя такое решение неэффективно, но оно гарантирует, что алгоритм сможет закодировать любое сообщение.
Можно улучшить алгоритм для данного случая, если вместо <offset,length,symbol> записывать либо нулевой бит, а затем <offset,length>, либо единичный бит, а затем <symbol>.Такая версия алгоритма называется LZS и тратит на одиночные символы гораздо меньше бит.
Также для ускорения сжатия для поиска совпадения в словаре использовалась хэш таблица и словарь был представлен циклическим буфером.

\subsubsection*{LZ77 декомпрессия}

Декодер LZ77 тривиально прост и может работать со скоростью, приближающейся к скорости процедуры обычного копирования информации.
В стандартной версии LZ77 мы считываем количество бит, которым кодируется <offset,length,symbol>, после чего находим нужную позицию в тексте с помощью offset и копируем посимвольно length символов, после чего пишем символ symbol.
В улучшенной версии LZS сначала декодер считывает один бит, чтобы определить, закодирована ли пара <offset,length> или <symbol>. Если это символ, то следующие 8 битов выдаются как раскодированный символ и помещаются в скользящее окно. Иначе, если это не закодированный конец файла, то соответствующее количество символов словаря помещается в окно и выдается в раскодированном виде.
Для ускорения работы запись раскодированных данных ведётся не сразу в выходной файл, а в буфер, который при заполнении записывается в файл.
Поскольку это все, что делает декодер, понятно, почему процедура декодирования работает так быстро.

По окончании чтения архива, количество байт, которое было в изначальном файле, сверяется с тем, сколько было записано в его новую версию. При несовпадении выводится соответствующее сообщение, и декомпрессия завершается неудачно.

\subsection*{Описание файлов программы}

Код программы разбит на 9 файлов:

\begin{enumerate}
	\item ACC.h - Содержит базовую информацию о классе TACC, необходимом для работы компрессии и декомпрессии соответствующего алгоритма. 
	\item ACC.cpp - Содержит реализацию класса TACC.
	\item BFile.h - Содержит базовую информацию о классах TOutBinary и класса TInBinary, необходимых для работы с файлами.
	\item BFile.cpp - Содержит реализацию классов TOutBinary и TInBinary.
	\item interface.h - Содержит в себе перечисление и описание всех функций необходимых для взаимодействия программы и алгоритмов сжатия данных.
	\item interface.cpp - Содержит реализацию всех функций, описанных в файле interface.h.
	\item Library.h - Содержит в себе ключи, необходимые для работы алгоритмов, и библиотеки для работы всей программы.
	\item LZ77.h - Содержит базовую информацию о классе TLZ77, необходимом для работы компрессии и декомпрессии соответствующего алгоритма.
	\item LZ77.cpp - Содержит реализацию класса TLZ77.
	\item main.cpp - Файл запуска.
	\item Makefile - Сборочный файл.
\end{enumerate}

\subsection*{Основные типы данных}

\begin{enumerate}
	\item TOutBinary - класс, обеспечивающий запись необходимого количества байт в файл.
	\item TInBinary - класс обеспечивающий считывание необходимого количества байт из файла.
	\item TLZ77 - класс, описывающий работу алгоритма LZ77.
	\item TACC - класс, описывающий работу арифметического алгоритма.
\end{enumerate}

\subsection*{Описание методов и функций программы}
 
\subsubsection*{Основные свойства и методы класса TACC}
\noindent
public:

\begin{enumerate}
	\item bool Compress (const char*, const char*) - сжатие файла.
	\item bool Decompress (const char*, const char*) - распаковка файла.
	\item TACC() - конструктор, в котором задаются начальные значения для последующей работы со сжатием/распаковкой файла.
\end{enumerate}
\noindent
private:

\begin{enumerate}
	\item bool chError - флаг ошибки при распаковке файла.
	\item unsigned char indexToChar [NO\_OF\_SYMBOLS] - таблица перевода из индексов к символам.
	\item int charToIndex [NO\_OF\_CHARS] - таблица перевода из символов в индексы.
	\item int cumFreq [NO\_OF\_SYMBOLS + 1] - массив накопленных частот. Нужен для определения границ.
	\item int freq [NO\_OF\_SYMBOLS + 1] - массив частот. В нём хранится число появлений тех или иных символов.
	\item long low - нижняя граница отрезка. 
	\item long high - верхняя граница отрезка.
	\item long value - число, которое лежит в отрезке.
	\item long bitsToFollow - количество бит, которые надо пустить в след за следующим выставляемым битом.
	\item int buffer - буффер для работы с файлом.
	\item int bitsToGo - число битов, которые ещё можно загрузить в буфер.
	\item int garbageBits - счётчик плохих битов при распаковке файла. Как только их становится слишком много - распаковка отменяется и выводится сообщение об этом.
	\item FILE *out - файл, в который мы записываем.
	\item FILE *in - файл, из которого мы считываем.
	\item void UpdateModel (int) - обновление модели под новый символ.
	\item void EncodeSymbol (int) - кодировка символа.
	\item void InputFileInfo() - запись информации о сжимаемом файле.
	\item void StartEncoding() - подготовка к сжатию.
	\item void DoneEncoding() - завершение кодирования. Загрузка последних битов в буфер.
	\item void StartDecoding() - подготовка к распаковке.
	\item int DecodeSymbol() - распаковка символа.
	\item int InputBit() - получение одного бита из файла.
	\item void OutputBit(int) - отправление одного бита в файл.
	\item void OutputBitPlusFollow(int) - вывод указанного бита и отложенных ранее.
\end{enumerate}

\subsubsection*{Основные свойства и методы класса TOutBinary}
\noindent
public:

\begin{enumerate}
	\item TOutBinary() - задаёт начальные значения. Файл не будет открыт.
	\item bool Open(std::string*) - открывает файл.
	\item bool Close() - закрывает файл.
	\item bool Write(const char*, size\_t) - запись в файл.
	\item bool WriteBin(size\_t bit) - запись бита в файл.
	\item unsigned long long SizeFile() - подсчёт размера файла.
	\item friend bool operator << (TOutBinary\& file, size\_t const \&bit) - запись бита в файл.
\end{enumerate}
\noindent
private:

\begin{enumerate}
	\item std::ofstream out - файл вывода.
    \item std::string name - имя файла.
    \item unsigned char head - маска для заноса бита в block.
    \item unsigned char block - временный буфер для хранения и записи битов в файл.
\end{enumerate}

\subsubsection*{Основные свойства и методы класса TInBinary}
\noindent
public:

\begin{enumerate}
	\item TInBinary() - задаёт начальные значения. Файл не будет открыт.
	\item bool Open(std::string*) - открывает файл.
	\item bool Close() - закрывает файл.
	\item bool Read(char*, size\_t) - считывает из файла некоторое количество байт.
	\item bool ReadBin(char* bit) - считывает из файла один бит.
	\item unsigned long long SizeFile() - подсчёт размера файла.
	\item friend bool operator >> (TInBinary\& iFile, char \&bit) - получение бита из файла.
\end{enumerate}
\noindent
private:

\begin{enumerate}
	\item std::ifstream in - файл вывода.
    \item std::string name - имя файла.
    \item unsigned char head - маска для заноса бита в block.
    \item unsigned char block - временный буфер для хранения битов из файла, через него получают биты.
\end{enumerate}

\subsubsection*{Основные свойства и методы класса TLZ77}
\noindent
public:

\begin{enumerate}
	\item TLZ77() - стандартный конструктор.
	\item TLZ77(IStruct s) - конструктор через вспомогательную структуру IStruct.
	\item InitEncode() - инициализирует данные необходимые для сжатия.
	\item Compress(std::string in\_str, std::string out\_str) - сжатие файла. 
	\item Decompress(std::string in\_str, std::string out\_str) -  распаковка файла.
	\item LoadDict(unsigned int dictpos) - загрузка словаря из файла в циклический буфер на позиции dictpos.
	\item DeleteData(unsigned int dictpos) - удаления всех ссылок на удаляемый сектор с началом в dictpos.
	\item HashData(unsigned int dictpos, unsigned int bytestodo) - хэширование и запись ссылок на возможное преведущее совпадение в словаре.
	\item FindMatch(unsigned int dictpos, unsigned int startlen) - поиск максимального совпадения в словаре с позицией dictpos, не меньше чем startlen. 
	\item DictSearch(unsigned int dictpos, unsigned int bytestodo) - кодирование считанного сектора с началом в dictpos и длинной bytestodo.
	\item SendChar(unsigned int character) - кодирование символа character.
	\item SendMatch(unsigned int matchlen, unsigned int matchdistance) - кодирование пары <matchlen, matchdistance>.
	\item ReadBits(unsigned int numbits) - считывание numbits битов из файла.
	\item SendBits(unsigned int bits, unsigned int numbits) - отправка numbits битов записанных в bits в файл.
	\item $\sim$TLZ77() - деструктор.
\end{enumerate}
\noindent
private:

\begin{enumerate}
	\item const int compressFloor - минимальное совпадение, для записи в виде<length,offset>.
	\item const int comparesCeil  - максимальное число раз которое ищется совпадение в FindMatch.
	\item const int CHARBITS    - сколькими битами кодируется символ.
	\item const int MATCHBITS     - сколькими битами кодируется длина совпадения.     
	\item const int DICTBITS     - сколькими битами кодируется длина словаря(offset).     
	\item const int HASHBITS     - сколько бит в хэше.
	\item const int SECTORBITS     - сколько бит в секторе.    
	\item const unsigned int MAXMATCH - максимальная кодируемая длина совпадения.
	\item const unsigned int DICTSIZE - размер словаря.
	\item const unsigned int HASHSIZE - размер хэша.
	\item const unsigned int SHIFTBITS  - на сколько происходит сдвиг при хэшировании.
	\item const unsigned int SECTORLEN  - размер сектора.
	\item const unsigned int SECTORAND  - нужен для определения к какому сектору относится то или иное место в словаре.
	\item unsigned char* dict - ссылка на словарь размером DICTSIZE.
	\item unsigned int *hash - ссылка на хэш размером HASHSIZE.
	\item unsigned int *nextlink - ссылка на массив, на каждой позиции которого хранится позиция предыдущего вхождения подстроки с совпадающим хэшем.
	\item unsigned int matchlength - длина совпадения, применяется в FindMatch, DictSearch.
	\item unsigned int  matchpos - позиция совпадения, применяется там же.
	\item unsigned int  bitbuf - буфер, который используется для записи и чтения бит из файла.
	\item unsigned int  bitsin - сколько битов находится в буфере в данный момент.
	\item unsigned int  masks[17] - маски для побитового чтения/записи.
	\item FILE *infile, *outfile; - файлы из которых идёт считывание/запись.
\end{enumerate}
\subsubsection*{Прочие функции}
\noindent
\begin{enumerate} 
	\item void FileIterator(std::map<std::string, int>) - Осуществляет проход по всем папкам и файлам для их компрессии/декомпрессии.
	\item bool Parser(std::map<std::string, int>*, std::string) - фильтрует полученные при вводе аргументы. При получении некорректного аргумента возвращает false.
	\item bool AskDir(std::string, bool) - Проверка на существование директории. При существовании возвращает true, в любом ином случае false.
	\item void DirectoryWork(std::string) - В случае наличия ключа -r осуществляет работу с внутренними файлами и директориями указанной директории.
	\item void DeComPress(std::string) - Помогает определить действия по отношению к указанному файлу: совершить компрессию, декомпрессию или посмотреть информацию об архиве.
	\item bool Rewrite(std::string) - В случае возможного повторения имён файлов при компрессии/декомпрессии принимает решение о перезаписи.
	\item void ErrorNotes(std::string) - Показывает сообщения об ошибках, возникших при работе с указанной директорией.
	\item bool KeyL(TInBinary*, std::string) - Осуществляет работу ключа -l - вывод информации об архиве.
	\item void PreCompress(TInBinary*, std::string) - Осуществляет подготовку указанного файла к сжатию в соответствии с указанными ключами.
	\item unsigned long long int Compress(std::string, TInBinary*, bool) - Непосредственно активирует указанный алгоритм сжатия. Возвращает размер полученного архива или 0 в случае ошибки.
	\item void PreDecompress(TInBinary*, std::string) - Осуществляет подготовку указанного файла к разжатию в соответствии с указанными ключами.
\end{enumerate}

\subsection*{Исходный код}

\lstset{language=C++,
	basicstyle=\ttfamily,
	keywordstyle=\color{green}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{blue}\ttfamily,
	morecomment=[l][\color{magenta}]{\#},
	frame=lines,
	breaklines=true,
	breakatwhitespace=false
}

\subsubsection*{ACC.h}
\lstinputlisting{forListing/ACC.h}
\subsubsection*{ACC.cpp}
\lstinputlisting{forListing/ACC.cpp}
\subsubsection*{BFile.h}
\lstinputlisting{forListing/BFile.h}
\subsubsection*{BFile.cpp}
\lstinputlisting{forListing/BFile.cpp}
\subsubsection*{interface.h}
\lstinputlisting{forListing/interface.h}
\subsubsection*{interface.cpp}
\lstinputlisting{forListing/interface.cpp}
\subsubsection*{Library.h}
\lstinputlisting{forListing/Library.h}
\subsubsection*{LZ77.h}
\lstinputlisting{forListing/LZ77.h}
\subsubsection*{LZ77.cpp}
\lstinputlisting{forListing/LZ77.cpp}
\subsubsection*{main.cpp}
\lstinputlisting{forListing/main.cpp}

\subsection*{Тест производительности}

\noindent
\begin{tabular}{| l | l | l | l | l | l | l |}
	\hline
	Файл             & Размер 	  & Алгоритм   & Время  & Время        & Размер    & Коэффициент \\
	                 & исходного  &            & сжатия & декомпрессии & сжатого   & сжатия      \\
	                 & файла (B)  &            & (с)    & (с)          & файла (B) &             \\
	\hline
	world95.txt      & 3005020    & LZ77       & 0.5    & 0.1          & 1502185   & 2\\
	\hline
	world95.txt      & 3005020    & Арифметика & 1.3    & 1.5          & 1917592   & 1.6\\
	\hline
	world95.txt      & 3005020    & оба        & 1.7    & 0.1          & 1502185   & 2\\
	\hline
	world95.txt      & 3005020    & gzip       & 0.4    & 2.5          & 878248    & 3.4\\
	\hline
	enwik8           & 100000000  & LZ77       & 14.5   & 2.8          & 46965090  & 2.1\\
	\hline
	enwik8           & 100000000  & Арифметика & 43.3   & 49.3         & 62762905  & 1.6\\
	\hline
	enwik8           & 100000000  & оба        & 56.1   & 2.8          & 46965090  & 2.1\\
	\hline
	enwik8           & 100000000  & gzip       & 11.2   & 3.8          & 36518329  & 2.7\\
	\hline
	enwik9           & 1000000000 & LZ77       & 138    & 26.4         & 432608909 & 2.3\\
	\hline
	enwik9           & 1000000000 & Арифметика & 439.9  & 543.5        & 635524001 & 1.6\\
	\hline
	enwik9           & 1000000000 & оба        & 559.9  & 26.3         & 432608909 & 2.3\\
	\hline
	enwik9           & 1000000000 & gzip       & 99.1   & 31.8         & 323742886 & 3.1\\
	\hline
	

\end{tabular}

\begin{itemize}
	\item Центральный процессор - Mobile DualCore Intel Celeron 1017U, 1600 MHz (16 x 100)
	\item Графический адаптер - Intel(R) HD Graphics (834742 KB)
	\item Оперативная память - DDR3-1333 DDR3 SDRAM 2 GB
\end{itemize}

\subsection*{Выводы}

В процессе выполнения данной работы я освоил 2 вида кодирования: арифметическое и LZ77. Это два совершенно разных по сути алгоритма. К примеру, LZ77 стремится сжать файл за счёт каких-либо повторений в нём. Арифметическое кодирование в свою очередь полностью опирается на чтение отдельных символов и их частоту появления. 

Зачастую арифметика оказывалась хуже LZ77. На такой результат могло повлиять большое количество повторений в тексте. Вполне возможно если речь пойдёт о картинках, которые, как мы знаем, сохраняются в виде зачастую повторяющихся последовательностей, то результат LZ77 будет ещё лучше.

Благодаря освоению двух алгоритмов сразу у меня появились представления о рабоче прочих алгоритмов кодирования и стали очевидны различные требования к их работе и результату. Были существенно улучшены навыки работы с файлами: проверка наличия, запись, чтение, перепись.

\subsection*{Список литературы}
\begin{enumerate}
	\item Алгоритм LZ77 [Электронный ресурс]: mf.grsu.by URL:\\ http://mf.grsu.by/UchProc/livak/po/comprsite/theory\_lz77.html (дата обращения\\ 10.08.2020)
	\item Алгоритмы LZW, LZ77 и LZ78 [Электронный ресурс]: habr.com URL:\\ https://habr.com/ru/post/132683/ (дата обращения 23.08.2020)
	\item Арифметическое кодирование [Электронный ресурс]: mf.grsu.by URL:\\ http://mf.grsu.by/UchProc/livak/po/comprsite/theory\_arithmetic.html (дата обращения 30.08.2020)
	\item Идея арифметического кодирования [Электронный ресурс]: algolist.ru URL:\\ http://algolist.ru/compress/standard/arithm.php (дата обращения 02.09.2020)
	\item Arithmetic coding - integer implementation [Электронный ресурс]: stringology.org URL: http://www.stringology.org/DataCompression/ak-int/index\_en.html (дата обращения 26.09.2020)
\end{enumerate}
\end{document}