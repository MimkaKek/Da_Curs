\documentclass[12pt]{article}
\usepackage{indentfirst}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.png}

\begin{document}
\begin{titlepage}
	\begin{center}
		\bfseries
		
		{\Large Московский авиационный институт\\ (национальный исследовательский университет)
			
		}
		
		\vspace{48pt}
		
		{\large Факультет информационных технологий и прикладной математики
		}
		
		\vspace{36pt}
		
		
		{\large Кафедра вычислительной математики и~программирования
			
		}
		
		
		\vspace{48pt}
		
		Курсовая работа по курсу <<Дискрeтный анализ>>: Методы сжатия данных
	\end{center}
	
	\vspace{72pt}
	
	\begin{flushright}
		\begin{tabular}{rl}
			Студент: & В.\,В. Гринин  \\
			Преподаватель: & Н.\,А. Зацепин \\
			Группа: & М8О-408Б \\
			Дата: & \\
			Оценка: & \\
			Подпись: & \\
		\end{tabular}
	\end{flushright}
	
	\vfill
	
	\begin{center}
		\bfseries
		Москва, \the\year
	\end{center}
\end{titlepage}

\pagebreak

\subsection*{Условие}

Необходимо реализовать два известных метода сжатия данных: LZW и Арифметическое кодирование. 

Формат запуска должен быть аналогичен формату запуска программы gzip, должны быть поддержаны следующие ключи: -c, -d, -k, -l, -r, -t, -1, -9. Должно поддерживаться указание символа дефиса в качестве стандартного ввода.

\subsection*{Метод решения}

\subsubsection*{Обработка входных данных}

Для начала программа обрабатывает аргументы командной строки. Таковыми могут быть ключи или наименования файлов и директорий. Чтобы отделять ключи от обычных наименований, в качестве первого символа для ключей используется <<->>. В ходе изучения работы ключей программы gzip, были выявлены закономерности в их поведении. А именно:

\begin{enumerate}
    \item Если был введён ключ -t, то далее ключи -c, -k, -d, -1, -9 программа учитывать не будет.
    \item Если был введён ключ -l, то он делает ключи -c, -k, -d, -t, -1, -9 недействительными как сейчас, так и при их будущих вводах.
    \item В то же время сочетания -cd, -c1, -c9, -kd, -k1, -k9, а так же сочетания ключа -r со всеми остальными ключами не являются взаимоисключающими.
    \item Если же во время обработки ключей встречается неизвестный ключ, то программа прекращает свою работу с соответствующей ошибкой, как и утилита gzip.
\end{enumerate}

В случае если начальным символом не является <<->>, то оно заносится в красное дерево имён файлов/директорий. 

\subsubsection*{Работа с файлами}

Проверяется пустота дерева имён файлов/папок -- если дерево пустое то программа завершается. 

Если дерево не пустое, каждый его элемент сначала рассматривается как директория, затем как файл. Чтобы отделить дерикторию от файла, используется функция \texttt{opendir} из библиотеки \texttt{dirent.h}.

Если элемент является директорией, то проверяется активность ключа -r: ключ активирован -- идёт работа с директорией, нет -- пропуск файла. Если элемент является файлом, то никаких проверок не проводится и начинается непосредственная работа с ним.

\subsubsection*{Подготовка к сжатию}

Если у имени файла есть суффикс <<.gz>>, то, если отсутствует ключ -с, файл не обрабатывается. Программа по итогу выведет соответствующее сообщение. Если этого суффикса нет, то, если отсутствует ключ -с, проверяется наличие файла с тем же именем, но при этом ещё и с суффиксом. Если такой файл существует -- пользователю предлагают перезаписать этот файл. Если пользователь откажется, то работа с данным файлом прекращается.

Если отсутствуют ключи -1 и -9, то файл сжимается сразу двумя методами. По итогу сжатия получаем два временных файла. Далее сравниваются размеры файлов, где выбирается наименьший, который впоследствии и становится результатом работы программы. Тот файл, который больше, просто удаляется. Если применяется один из этих ключей, то программа использует один из двух алгоритмов. Для ключа -1 это LZW, а для ключа -9 это арифметическое кодирование.

В случае если какой-то из алгоритмов дал сбой, то прекращается работа с файлом и выводится соответствующая ошибка.

\subsubsection*{Подготовка к распаковке}

Для распаковки используется ключ -d. Проверяется наличие у файла суффикса <<.gz>>. Если он не имеется, то, если отсутствует ключ -с, работа с файлом прекращается и выведится соответствующее сообщение. Если имеется, то при отсутствии -t и -c проверяется наличие файла с тем же именем, но без суффикса <<.gz>>. При наличии такого файла, программа запрашивает разрешение на перезапись. В случае отказа завершается работа с файлом. Когда такого файла нет или пользователь дал согласие, то работа продолжается. Каждый архив, сжатый этой программой имеется первые несколько служебных байт, которые содержат в себе информацию о алгоритме сжатия и размере исходного файла. При считывании первого байта определяется алгоритм сжатия. Для LZW это символ <<L>>, для арифметического кодирования это <<A>>. Если это другой символ, то работа с файлом прекращается и выводится уведомление об ошибке. В случае неудачного завершения алгоритма, выводится соответствующее сообщение. При отсутствии ключей -t и -c удаляется файл, в который записывались данные после распаковки, и работа с файлом прекращается. Далее при отсутствии ключей -t, -c и -k, удаляется изначальный архив, а при отсутствии ключей -t и -c временный файл для распаковки переименовывается и получает имя изначального архива без расширения <<.gz>>.

\subsubsection*{Получение информации об архиве}

В случае указания ключа -l производятся следующие действия. Для начала программа считывает первый байт. В случае, если он не совпадает с символами, указывающими на метод сжатия, то выводится сообщение об ошибке и завершается работа с файлом. 

Далее читается 8 байт, в которые помещается размер файла до сжатия. После этого программа считывает размер архива, и вычисляется процент сжатия. Далее выводятся размер сжатого файла, размер до компрессии, процент сжатия в полуинтервале $[-100\%; 100\%)$ и имя файла до архивации (если файл имеет расширение <<.gz>>, то имя выводится без этого расширения, в противном случае выводится имя архива).

Далее незакодированный файл будет упоминаться как файл, а закодированный файл как архив.

\subsubsection*{LZW компрессия}

Компрессия методом LZW происходит по следующему принципу: из размера файла определяется верхняя граница буфера, в котором будут храниться слова, и каким количеством байт будут кодироваться слова, после чего строится префиксное дерево из всех односимвольных слов--символов ASCII. В архив записывается 9 байт информации, первый из которых - это указание метода архивации, а остальные 8 - размер изначального файла. Далее читается первый символ файла, и в архив записывается код соответствующего слова. Полученный символ указывает на узел, в который будет добавлен следующий символ. Затем символы считываются до создания новой вершины в префиксном дереве, а в архив записывается код вершины, предшествующей новой. Последняя буква, полученная до добавления вершины заносится в буфер. После чего из корня ищется вершина, к которой ведёт эта буква, и процесс повторяется вплоть до окончания символов в файле или создания максимального количества вершин, которое сможет прочитать декомпрессор. Если произошло второе, то в архив записывается $0$, (никак иначе на этом этапе он быть записан не может), ранее установленным количеством байт, из префиксного дерева удаляются все вершины кроме корневой и потомков первого рода, после чего процесс компрессии начинается заново, но позиции в исходном файле и архиве не получают откат. Если на каком либо этапе компрессии возникает ошибка, его работа прекращается, и выводится соответствующая ошибка.

\subsubsection*{LZW декомпрессия}

Декомпрессия начинается с прочтения размера изначального файла из архива, который необходим для определения нужно количества байт для прочтения слова и проверки на безошибочность декомпрессии. Далее, из архива считываются только коды слов определённого ранее размера. После считывания первого слова создаётся красно-чёрное дерево, и в него записываются все односимвольные слова из ASCII символов. Далее, по полученному коду в дереве находится необходимая строка, и она записывается в файл. После чего этот символ записывается во временное слово. Далее алгоритм считывает коды из архива. При обработке кодов возможны 4 ситуации:

\begin{enumerate}
	\item Код входит в список полученных слов. В этом случае в красно-чёрном дереве ищется слово с необходимым кодом, и это слово записывается в файл, после чего в красно-чёрное дерево записывается новое слово, которое является предыдущим словом, к которому добавили первую букву только что полученного. Декомпрессия продолжается.
	\item Код не входит в красно-чёрное дерево, но он является следующим по счёту, следовательно это слово можно интерпретировать как предыдущее, к которому дописали в конце букву, с которой оно начинается. Полученное слово записывается в файл и в красно-чёрное дерево, после чего декомпрессия продолжается.
	\item Код не входит в красно-чёрное дерево и не является следующим на подходе, следовательно архив повреждён. Декомпрессия прекращается, и выводится соответствующее сообщение.
	\item Код равен $0$. Красно-чёрное дерево очищается, и процесс декомпрессии начинается сначала, но позиции в файле и архиве не получают откат.
\end{enumerate}

По окончании чтения архива, количество байт, которое было в изначальном файле, сверяется с тем, сколько было записано в его новую версию. При несовпадении выводится соответствующее сообщение, и декомпрессия завершается неудачно.

\subsubsection*{Арифметическое сжатие}
В теории арифметическое сжатие описывается достаточно просто. У нас имеется промежуток от 0 до 1. Имеется таблица частот, в которой содержится информация о том, как часто встречается тот или иной символ. Промежуток разделяется на множество отрезков, каждый из которых представляет собой какой-либо символ. При считывании символа, мы переходим к его отрезку. Далее цикл повторяется, но уже с новыми границами, заданными этим символом. На практике же мы неизбежно сталкиваемся с машинным эпсилон, поэтому следует попробовать написать всё в целых числах.

На вход мы получаем файл. Создаём свой файл, в который мы заносим первые 9 байт. 1 байт обозначит тип сжатия, остальные 8 байт - размер исходного файла. По умолчанию у каждого символа частота выставлена на единицу.

Каждый символ кодируется по следующей схеме:

\begin{enumerate}
    \item Рассчёт границ символа по частоте его появления;
    \item Кодировка символа посредством цепочки манипуляций над границами. Если отрезок лежит в верхней половине допустимых значений - пишем бит равный единице. Если лежит в нижней половине - пишем бит равный нулю. Если лежит где-то по центру - увеличиваем счётчик битов, которые будут выставлены вслед за следующим битом с отличным от него значением. Если не выполняется ни одно из этих условий, т.е. получившийся отрезок достаточно большой, то кодировка завершается. Иначе - увеличиваем границы в 2 раза. По сути это аналогично побитовому сдвигу влево.
    \item Обновление таблицы частот. Если случилось переполнение, то масштабируем частоты, деля их на два и пересчитывая накопленные частоты. После этого производится сортировка таблицы, чтобы ускорить работу с ней.
\end{enumerate}
\subsubsection*{Арифметическая распаковка}
В теории мы получаем число, в котором закодированы символы. Далее мы определяем в каком отрезке лежит это число, благодаря чему узнаём о закодированном символе. Далее мы выбираем новые границы, а именно границы того отрезка. Разбиваем этот отрезок также на несколько частей, следуя таблице частот и аналогично узнаём следующий символ. Однако в текущей реализации используются целые числа, поэтому и декодирование немного отличается.

В первую очередь мы получаем такое же число. По нему мы также определяем границы, однако способ их нахождения несколько отличается - вместо того, чтобы сразу их узнать, мы сначала находим накопленную частоту и уже по ней определяем границы и закодированный символ. После этого мы по аналогичной схеме, как в кодировании символа, проводим манипуляции над границами и таким образом убираем ненужные биты. Далее мы начинаем декодировать следующий символ.

После декодирования символа мы также обновляем таблицу частот.

\subsection*{Описание файлов программы}

Код программы разбит на 13 файлов:

\begin{enumerate}
	\item ACC.h - Содержит перечисление методов и описание класса TArithmetic, необходимого для работы арифметической компрессии и декомпрессии. 
	\item ACC.cpp - Содержит реализацию всех методов класса TArithmetic.
	\item BFile.h - Содержит перечисление методов и описание класса TOutBinary и класса TInBinary, необходимых для записи в файл и чтения из файла соответственно.
	\item BFile.cpp - Содержит реализацию всех методов классов TOutBinary и TInBinary.
	\item Globals.h - Содержит в себе все необходимые глобальные переменные и библиотеки используемые несколькими файлами.
	\item LZW.h - Содержит перечисление методов и описание класса TLZW, необходимого для работы алгоритма LZW.
	\item LZW.cpp - Содержит реализацию всех методов класса TLZW.
	\item main\_help.h - Содержит в себе перечисление и описание всех функций необходимых для препроцессинга перед началом работы алгоритмов компрессии и декомпрессии.
	\item main\_help.cpp - Содержит реализацию всех функций, необходимых для препроцессинга, описанных в файле main\_help.h.
	\item Prefix.h - Содержит перечисление методов и описание класса TPrefix, необходимого для работы LZW компрессии.
	\item Prefix.cpp - Содержит реализацию всех методов класса TPrefix.
	\item main.cpp - Содержит в себе алгоритм чтения файлов и ключей.
	\item Makefile - Файл для сборки программы.
\end{enumerate}

\subsection*{Основные типы данных}

\begin{enumerate}
	\item TACC - класс, описывающий работу арифметического алгоритма компрессии и декомпрессии.
	\item TOutBinary - класс обеспечивающий запись необходимого количества байт в файл.
	\item TInBinary - класс обеспечивающий считывание необходимого количества байт из файла.
	\item TLZW - класс, описывающий работу алгоритма LZW.
	\item TPrefix - класс, обеспечивающий построение префиксного дерева для LZW сжатия.
\end{enumerate}

\subsection*{Описание методов и функций программы}
 
\subsubsection*{Основные свойства и методы класса TACC}
\noindent
public:

\begin{enumerate}
	\item bool Compress (const char*, const char*) - сжатие файла;
	\item bool Decompress (const char*, const char*) - распаковка файла;
	\item TACC() - конструктор, в котором задаются начальные значения для последующей работы со сжатием/распаковкой файла;
\end{enumerate}
\noindent
private:

\begin{enumerate}
	\item bool chError - флаг ошибки при распаковке файла;
	\item unsigned char indexToChar [NO\_OF\_SYMBOLS] - таблица перевода из индексов к символам;
	\item int charToIndex [NO\_OF\_CHARS] - таблица перевода из символов в индексы;
	\item int cumFreq [NO\_OF\_SYMBOLS + 1] - массив накопленных частот. Нужен для определения границ;
	\item int freq [NO\_OF\_SYMBOLS + 1] - массив частот. В нём хранится число появлений тех или иных символов;
	\item long low - нижняя граница отрезка; 
	\item long high - верхняя граница отрезка;
	\item long value - число, которое лежит в отрезке;
	\item long bitsToFollow - количество бит, которые надо пустить в след за следующим выставляемым битом;
	\item int buffer - буффер для работы с файлом;
	\item int bitsToGo - число битов, которые ещё можно загрузить в буффер;
	\item int garbageBits - счётчик плохих битов при распаковке файла. Как только их становится слишком много - распаковка отменяется и выводится сообщение об этом;
	\item FILE *out - файл, в который мы записываем;
	\item FILE *in - файл, из которого мы считываем;
	\item void UpdateModel (int) - обновление модели под новый символ;
	\item void StartInputingBits() - подготовка к побитовому вводу;
	\item void StartOutputingBits() - подготовка к побитовому выводу;
	\item void EncodeSymbol (int) - кодировка символа;
	\item void StartEncoding() - подготовка к сжатию;
	\item void DoneEncoding() - завершение кодирования. Загрузка последних битов в буффер;
	\item void StartDecoding() - подготовка к распаковке;
	\item int DecodeSymbol() - распаковка символа;
	\item int InputBit() - получение одного бита из файла;
	\item void OutputBit(int) - отправление одного бита в файл;
	\item void DoneOutputingBits() - отправление последних битов в файл;
	\item void OutputBitPlusFollow(int) - вывод указанного бита и отложенных ранее;
\end{enumerate}

\subsubsection*{Основные свойства и методы класса TOutBinary}
\noindent
public:

\begin{enumerate}
	\item TOutBinary() - задаёт начальные значения. Файл не будет открыт.
	\item bool Open(std::string*) - открывает файл;
	\item bool Close() - закрывает файл;
	\item bool Write(const char*, size\_t) - запись в файл;
	\item bool WriteBin(size\_t bit) - запись бита в файл;
	\item unsigned long long SizeFile() - подсчёт размера файла;
	\item friend bool operator << (TOutBinary\& file, size\_t const \&bit) - запись бита в файл;
\end{enumerate}
\noindent
private:

\begin{enumerate}
	\item std::ofstream out - файл вывода;
    \item std::string name - имя файла;
    \item unsigned char head - маска для заноса бита в block;
    \item unsigned char block - временный буффер для хранения и записи битов в файл;
\end{enumerate}

\subsubsection*{Основные свойства и методы класса TInBinary}
\noindent
public:

\begin{enumerate}
	\item TInBinary() - задаёт начальные значения. Файл не будет открыт.
	\item bool Open(std::string*) - открывает файл;
	\item bool Close() - закрывает файл;
	\item bool Read(char*, size\_t) - считывает из файла некоторое количество байт;
	\item bool ReadBin(char* bit) - считывает из файла один бит;
	\item unsigned long long SizeFile() - подсчёт размера файла;
	\item friend bool operator >> (TInBinary\& iFile, char \&bit) - получение бита из файла;
\end{enumerate}
\noindent
private:

\begin{enumerate}
	\item std::ifstream in - файл вывода;
    \item std::string name - имя файла;
    \item unsigned char head - маска для заноса бита в block;
    \item unsigned char block - временный буффер для хранения битов из файла, через него получают биты;
\end{enumerate}

\subsubsection*{Основные свойства и методы класса TLZW}
\noindent
public:

\begin{enumerate}
	\item TLZW(TInBinary*, TOutBinary*) - Конструктор класса. Передаются файл для чтения и файл для записи.
	\item bool Compress(std::string) - Производит компрессию данных. На вход получает имя файла для компрессии. В случае успешного выполнения возвращает true, иначе false.
	\item bool Decompress(std::string) - Производит декомпрессию данных. На вход получает имя файла для декомпрессии. В случае успешного выполнения возвращает true, иначе false.
	\item $\sim$TLZW() - Стандартный деконструктор.
\end{enumerate}
\noindent
private:

\begin{enumerate}
	\item TInBinary* ForRead - Файл для чтения.
	\item TOutBinary* ForWrite - Файл для записи.
	\item TPrefix* CompressionTree - Префиксное дерево для хранения слов при компрессии.
	\item std::map<unsigned long long int, std::string> DecompressionTree - Красно-чёрное дерево для хранения слов при декомпрессии.
\end{enumerate}

\subsubsection*{Основные свойства и методы класса TPrefix}

\noindent
public:

\begin{enumerate}
	\item TPrefix(TInBinary*, TOutBinary*) - Конструктор для корневой вершины. Передаются файл для чтения и файл для записи.
	\item TPrefix() - Конструктор для всех прочих вершин.
	\item int Update(char) - Добавление вершины из других вершин. Возвращает коды ошибок или успехов.
	\item int UpdateForRoot() - Добавление вершины из корня. Возвращает коды ошибок или успехов.
	\item void Clear(bool) - Очистка дерева после переполнения.
	\item $\sim$TPrefix() - Стандартный деконструктор.
\end{enumerate}
\noindent
private:

\begin{enumerate}
	\item std::vector<std::pair<char, TPrefix*>\hspace{0pt}> Next - Вектор потомков вершины и путей в них.
	\item unsigned long long int NumberOfWord - Номер слова в данном узле.
	\item static char LastLetter - Последняя прочитанная буква. Необходима для построения нового слова.
	\item static unsigned long long int NeedToRead - Вспомогательная переменная для чтения нужного кол-ва символов.
	\item static unsigned long long int LastNumber - Номер следующего добавленного слова.
	\item static unsigned long long int Border - Максимальная граница количества слов перед очисткой дерева.
	\item static TInBinary* ForRead - Файл для чтения.
	\item static TOutBinary* ForWrite - Файл для записи
	\item static unsigned short int Bites - Количество байт, необходимое для кодирования слова.
\end{enumerate}

\subsubsection*{Прочие функции}
\noindent
\begin{enumerate}
	\item bool KeyManager(std::string) - Обрабатывает полученные ключи. В случае получения неизвестного ключа возвращает false, иначе true.
	\item bool DifferensOfSizes(TInBinary*, std::string) - вывод для каждого файла размера сжатого, оригинального, коэффициента сжатия(\%) и имя оригинального файла(ключ l). В случае повреждения. архива возвращает false, иначе true.
	\item void WorkWithDirectory(std::string) - работает с директорией (ключ r).
	\item void WorkWithFile(std::string) - работает с файлом (определяет наличие файла, принимает решение о компрессии или декомпрессии, выполняет прочие ключи).
	\item bool IsDirectory(std::string, bool) - Проверяет, является ли файл директорией. Если файл является директорией, возвращает true, иначе false.
	\item void PrintDirectoryErrors(std::string) - Уведомляет об ошибках.
	\item bool IsArchive(std::string) - Проверяет, является ли файл архивом. Если файл является архивом, возвращает true, иначе false.
	\item void Rename(std::string, std::string) - Изменяет название файла после успешной компрессии или декомпрессии.
	\item void Delete(std::string) - Удаляет временный файл.
	\item void MainDecompress(TInBinary*, std::string) - Отвечает за подготовку декомпрессинга.
	\item void MainCompress(TInBinary*, std::string) - Отвечает за подготовку компрессинга.
	\item unsigned long long int LZWCompress(TInBinary*, std::string, TOutBinary*) - Подготавливает LZW компрессию. Возвращает размер нового файла.
	\item unsigned long long int ArithmeticCompress(TInBinary*, std::string) - Подготавливает арифметический компрессию. Возвращает размер нового файла.
	\item void KeepSmall(unsigned long long int, unsigned long long int,%TODO доковырять её
	unsigned long long int, std::string) - Сохраняет архив самого малого размера.
	\item int main(int, char*) - Осуществляет чтение входных данных.
\end{enumerate}

\subsection*{Исходный код}

\lstset{language=C++,
        basicstyle=\ttfamily,
        keywordstyle=\color{blue}\ttfamily,
        stringstyle=\color{red}\ttfamily,
        commentstyle=\color{green}\ttfamily,
        morecomment=[l][\color{magenta}]{\#}
        breaklines=true,
        frame=lines
}

\subsubsection*{ACC.cpp}
\lstinputlisting{Code/ACC.cpp}
\subsubsection*{ACC.h}
\lstinputlisting{Code/ACC.h}
\subsubsection*{BFile.cpp}
\lstinputlisting{Code/BFile.cpp}
\subsubsection*{BFile.h}
\lstinputlisting{Code/BFile.h}
\subsubsection*{Globals.h}
\lstinputlisting{Code/Globals.h}
\subsubsection*{LZW.cpp}
\lstinputlisting{Code/LZW.cpp}
\subsubsection*{LZW.h}
\lstinputlisting{Code/LZW.h}
\subsubsection*{Prefix.cpp}
\lstinputlisting{Code/Prefix.cpp}
\subsubsection*{Prefix.h}
\lstinputlisting{Code/Prefix.h}
\subsubsection*{main.cpp}
\lstinputlisting{Code/main.cpp}
\subsubsection*{main\_help.cpp}
\lstinputlisting{Code/main_help.cpp}
\subsubsection*{main\_help.h}
\lstinputlisting{Code/main_help.h}
\subsection*{Тест производительности}

Для начала рассмотрим эффективность работы утилиты gzip.
\\
\\
\noindent
\begin{tabular}{| l | l | l | l | l | l | l |}
\hline
Файл         & Размер       & Алгоритм & Время  & Время        & Размер    & Коэффициент \\
             & исходного    &          & сжатия & <<разжатия>> & сжатого   & сжатия\\
             & файла &          & (с)    & (с)          & файла     & \\
 \hline
world95.txt  & 3006464      & gzip     & 0.158  & 0.072        & 880640    & 3.414\\       
 \hline
enwik8       & 100003840    & gzip     & 6.417  & 0.887        & 36519936  & 2.738\\
 \hline
enwik9       & 1000005632   & gzip     & 50.881 & 11.889       & 323743744 & 3.089\\
 \hline

 \hline
\end{tabular}
\\
\\
Пока что-то сказать сложно, но ясно одно - утилита выполняет свою работу быстро и корректно. Теперь к курсовой работе. 
\\
\\
\noindent
\begin{tabular}{| l | l | l | l | l | l | l |}
\hline
Файл         & Размер       & Алгоритм      & Время   & Время        & Размер       & Коэффициент \\
             & исходного    &               & сжатия  & <<разжатия>> & сжатого      & сжатия\\
             & файла &               & (с)     & (с)          & файла & \\
 \hline
world95.txt  & 3006464      & Оба алгоритма & 1.504   & 0.897        & 1716224      & 1.752\\       
 \hline
enwik8       & 100003840    & Оба алгоритма & 65.907  & 37.150       & 48697344     & 2.054\\
 \hline
enwik9       & 1000005632   & Арифметика    & 282.655 & 280.363      & 635531264    & 1.573\\
 \hline

 \hline
\end{tabular}
\\

Небольшое пояснение по алгоритмам. В случае первых двух файлов программа проходила по двум алгоритмам и выбирала тот, что лучше отработал. Однако там в обоих случаях хорошо себя показала арифметика. В первую очередь тут могло сказаться, что в тексте последовательности не так часто повторяются, как хотелось бы. Для арифметики наличие каких-то повторяющихся последовательностей не важно, однако ей выгодно встречать как можно больше и чаще относительно маленький набор символов. Думаю, LZW лучше будет работать для сжатия изображений, так как там больше шансов встретить повторяющиеся последовательности.

Помимо этого можно заметить, что на последнем файле используется только арифметика. Причина в том, что LZW использует дерево, которое неплохо так разрослось, из-за чего ОС в целом тормозила. Пришлось экстренно прекратить программу и сжать только при помощи арифметики, так как она не использует динамические структуры.

Если сравнивать с самим gzip, то очевидно, что он сжимает гораздо лучше и быстрее. Особенно это чувствуется с файлами огромного размера. Также из интересного можно заметить, что на файле enwik8 распаковка у gzip проходила крайне быстро, особенно на фоне программы из курсовой работы.

Тесты проводились на ноутбуке со следующими техническими характеристиками:
\begin{itemize}
    \item Центральный процессор: Intel® Core™ i5-7200U CPU @ 2.50GHz х 4
    \item Графический адаптер: Mesa Intel® HD Graphics 620 (KBL GT2)
    \item Оперативная память: 8 ГБ.
\end{itemize}   

\subsection*{Выводы}

В ходе выполнения работы была написана программа, взаимодействующая с файловой системой, а также реализующая LZW и арифметическое сжатие.

Оба алгоритма с точки зрения сложности концепции одинаково просты. Однако когда речь доходит до реализации, то картина меняется.

В случае арифметического кодирования если мы будем пытаться написать его на основе чисел с плавающей точкой, то мы сталкиваемся с двумя проблемами:
\begin{itemize}
    \item Числа с плавающей точкой сами по себе занимают большое количество бит, что отражается на том минимуме символов, который необходим, чтобы файл в целом стал меньше.
    \item Может сильно помешать машинный эпсилон. Из-за него порой файлы не получалось нормально сжать.
\end{itemize}
По этим причинам пришлось искать целочисленный способ кодирования, который в свою очередь уже сложнее в реализации и менее очевиден для понимания. Но это в лучшую сторону сказалось на эффективности сжатия.

В случае LZW единственную сложность вызвала реализация префиксного дерева. А по остальному всё довольно просто.

\subsection*{Список литературы}
\begin{enumerate}
	\item Арифметическое кодирование [Электронный ресурс]: mf.grsu.by URL:\\ http://mf.grsu.by/UchProc/livak/po/comprsite/theory\_arithmetic.html (дата обращения 14.07.2020)
	\item Арифметическое кодирование [Электронный ресурс]: habr.com URL:\\ https://habr.com/ru/post/130531/ (дата обращения 26.08.2020)
	\item Алгоритм LZW [Электронный ресурс]: mf.grsu.by URL:\\ http://mf.grsu.by/UchProc/livak/po/comprsite/theory\_lzw.html \\(дата обращения 26.08.2020)
\end{enumerate}
\end{document}