\documentclass[12pt]{article}
\usepackage{indentfirst}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{listings}

\begin{document}
\begin{titlepage}
	\begin{center}
		\bfseries
		
		{\Large Московский авиационный институт\\ (национальный исследовательский университет)
			
		}
		
		\vspace{48pt}
		
		{\large Факультет информационных технологий и прикладной математики
		}
		
		\vspace{36pt}
		
		
		{\large Кафедра вычислительной математики и~программирования
			
		}
		
		
		\vspace{48pt}
		
		Курсовая работа по курсу <<Дискрeтный анализ>>: Методы сжатия данных
	\end{center}
	
	\vspace{72pt}
	
	\begin{flushright}
		\begin{tabular}{rl}
			Студент: & А.\,М. Титеев  \\
			Преподаватель: & Н.\,А. Зацепин \\
			Группа: & М8О-408Б \\
			Дата: & \\
			Оценка: & \\
			Подпись: & \\
		\end{tabular}
	\end{flushright}
	
	\vfill
	
	\begin{center}
		\bfseries
		Москва, \the\year
	\end{center}
\end{titlepage}

\pagebreak
\subsection*{Условие}

Необходимо реализовать два известных метода сжатия данных для сжатия одного файла. 

Формат запуска должен быть аналогичен формату запуска программы gzip, должны быть поддержаны следующие ключи: c, d, k, l, r, t, 1, 9. Должно поддерживаться указание символа дефиса в качестве стандартного ввода.

\subsection*{Метод решения}

Как и требуется в условии запуск программы аналогичен запуску утилиты gzip: ./main <ключи> <файлы> <ключи> <файлы> ...

\subsubsection*{Препроцессинг}

На первом этапе работы программа определяет наличие в поступившей строке ключей, директорий и файлов.
При обработке ключей учитывается их взаимоперекрываение, как в утилите gzip: l и r имеют наибольший приоритет, далее идёт ключ t, после чего остальные. В случае, если новый ключ перекрывает по логике утилиты некоторые из уже имеющихся, то эти ключи деактивируются.

Если полученное слово из стандартного ввода не является ключом, то программа проверяет наличие директории с таким именем. Если такой директории нет, то считается, что это имя файла, и оно заносится в список файлов. Если директория с таким именем существует и подключён ключ r, то все файлы внутри этой директории добавляются в список.

После с файлами ведётся работа согласно введённым ключам.

\subsubsection*{Арифметический алгоритм}

В этой программе реализованная целочисленная арифметика. Причина проста - машинам лучше и проще работать с целыми числами, чем с числами с плавающими точками. Например, наличие машинного эпсилон.

Перед обяъснением алгоритма стоит упомянуть ряд моментов. Во-первых, так как мы имеем дело с целыми числами, это значит, что у нас нет возможности бесконечно переходить к меньшим отрезкам. Поэтому в данной реализации работа с отрезками сводится к их масштабированию, параллельно записывая нужные биты. Во-вторых, для работы внутри рассматриваемого отрезка используется таблица частот, которая содержит в себе информацию о том, насколько часто встречается тот или иной символ. Это необходимо для нужного разбиения на ещё более мелкие отрезки.

Данная реализация делится на несколько фаз:
\begin{itemize}
	\item Подготовительная фаза - производится инициализация буфера, куда будут записываться биты, счётчиков, начального отрезка и таблицы частот. Отдельно стоит упомянуть, что начальные значения частот у каждого символа изначально стоят как единицы. Это необходимо корректной работы с отрезком. Помимо этого также в файл заносится служебная информация, где указано, каким алгоритмом сжали и какой был размер исходного файла.
	\item Основная фаза - производится кодировка символов. Каждому символу в начале сопоставляется соответствующий маленький отрезок, с которым в дальнейшем происходит масштабирование и смещение, дабы избежать переполнения. В процессе заносятся соответствующие биты. После того, как дальнейшее масштабирование становится невозможным, кодировка символа завершается. Обновляется таблица частот в соответствии с символом.
	\item Завершающая фаза - когда символы закодированы, программа кодирует EOF и дозаписывает недостающие биты. На этом работа с файлом завершается.
\end{itemize}

В процессе декомпрессии алгоритм будет часто обращаться к таблице частот, поэтому надо максимально сильно сократь работу с ней, чтобы алгоритм не просел по времени. Для этого есть довольно простое решение - в процессе декомпресси во время обновления таблицы будет производиться её небольшая сортировка. Сортировка сводится к тому, чтобы часто попадающиеся символы были ближе к началу таблицы. Это и ускоряет декомпрессию.

Аналогично компрессии, декомпрессию можно разделить на несколько фаз:
\begin{itemize}
	\item Подготовительная фаза - почти аналогично компрессии, но с некоторыми отличиями. Иницилизируется специальная переменная, которая будет содержать в себе биты, которые были в сжатом файле. Также в файл ничего не записывается, а производится лишь чтение.
	\item Основная фаза - при помощи специальной переменной определяем символ. Проводим такие же манипуляции с отрезком, как и в сжатии, параллельно загружая новые биты из файла и отбрасывая уже лишние. После этого аналогично компрессии обновляется таблица частот.
	\item Завершающая фаза - после получения кода об EOF декомпрессия завершается. Весь результат декомпрессии по ходу заносится в новый файл.
\end{itemize}

\subsubsection*{LZ77}%TODO Саня



\subsection*{Описание файлов программы}

Код программы разбит на 9 файлов:

\begin{enumerate}
	\item Arithmetic.h - Описывает класс Arithmetic, в котором заключён соответствующий алгоритм кодирования. 
	\item Arithmetic.cpp - Реализует класс Arithmetic.
	\item Globals.h - Файл с общими библиотеками.
	\item LZ77.h - Описывает класс LZ77, в котором заключён соответствующий алгоритм кодирования.
	\item LZ77.cpp - Реализует класс LZ77.
	\item main.cpp - Основной файл, отвечающий за чтение входных данных и принятие действий относительно каждого файла.
	\item Makefile - Файл для сборки программы.
	\item preprocessing.h - Содержит прототипы функций, необходимых для обработки данных перед компрессией/декомпрессией.
	\item preprocessing.cpp - Реализует все функции из соответствующей библиотеки.
\end{enumerate}

\subsection*{Основные типы данных}

\begin{enumerate}
	\item Arithmetic - Реализует соответствующий алгоритм.
	\item LZ77 - Реализует соответствующий алгоритм.
\end{enumerate}

\subsection*{Описание методов и функций программы}
 
\subsubsection*{Основные свойства и методы класса Arithmetic}
\noindent
public:

\begin{enumerate}
	\item bool Compress (const char*, const char*) - сжатие файла;
	\item bool Decompress (const char*, const char*) - распаковка файла;
	\item Arithmetic() - конструктор, в котором задаются начальные значения для последующей работы со сжатием/распаковкой файла;
\end{enumerate}
\noindent
private:

\begin{enumerate}
	\item bool chError - флаг ошибки при распаковке файла.
	\item unsigned char indexToChar [NO\_OF\_SYMBOLS] - таблица перевода из индексов к символам.
	\item int charToIndex [NO\_OF\_CHARS] - таблица перевода из символов в индексы.
	\item int cumFreq [NO\_OF\_SYMBOLS + 1] - массив накопленных частот. Нужен для определения границ.
	\item int freq [NO\_OF\_SYMBOLS + 1] - массив частот. В нём хранится число появлений тех или иных символов.
	\item long low - нижняя граница отрезка. 
	\item long high - верхняя граница отрезка.
	\item long value - число, которое лежит в отрезке.
	\item long bitsToFollow - количество бит, которые надо пустить в след за следующим выставляемым битом.
	\item int buffer - буффер для работы с файлом.
	\item int bitsToGo - число битов, которые ещё можно загрузить в буфер.
	\item int garbageBits - счётчик плохих битов при распаковке файла. Как только их становится слишком много - распаковка отменяется и выводится сообщение об этом.
	\item FILE *out - файл, в который мы записываем.
	\item FILE *in - файл, из которого мы считываем.
	\item void UpdateModel (int) - обновление модели под новый символ.
	\item void StartInputingBits() - подготовка к побитовому вводу.
	\item void StartOutputingBits() - подготовка к побитовому выводу.
	\item void EncodeSymbol (int) - кодировка символа.
	\item void StartEncoding() - подготовка к сжатию.
	\item void DoneEncoding() - завершение кодирования. Загрузка последних битов в буфер.
	\item void StartDecoding() - подготовка к распаковке.
	\item int DecodeSymbol() - распаковка символа.
	\item int InputBit() - получение одного бита из файла.
	\item void OutputBit(int) - отправление одного бита в файл.
	\item void DoneOutputingBits() - отправление последних битов в файл.
	\item void OutputBitPlusFollow(int) - вывод указанного бита и отложенных ранее.
\end{enumerate}

\subsubsection*{Основные свойства и методы класса LZ77}%TODO Саня
\noindent
public:

\begin{enumerate}
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
\end{enumerate}
\noindent
private:

\begin{enumerate}
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
\end{enumerate}

\subsubsection*{Прочие функции} 
\noindent
\begin{enumerate}
	\item void Compress(std::string) - Создает необходимые для компрессии данные (временные файлы).
	\item void Decompress(std::string) - Создает необходимые для декомпрессии данные (классы и временные файлы).
	\item bool ActivateKeys(std::string) - Активирует или деактивирует указанные в аргументах ключи. Из-за некорректного ключа функция возвращает false и завершает работу программы. 
	\item void ArchiveInfo(std::string) - Выводит информацию об архиве.
	\item unsigned long long int CompressA(std::string) - Создаёт класс для арифметического кодирования и работает с ним. При некорректной работе алгоритма возвращает 0, иначе количество байт в получившемся файле.
	\item unsigned long long int CompressL(std::string) - Создаёт класс для кодирования LZ77 и работает с ним. При некорректной работе алгоритма возвращает 0, иначе количество байт в получившемся файле.
	\item bool ArchiveCheck(std::string) - Проверка на наличие у файла суффикса <<.gz>>.
	\item bool DirectoryCheck(std::string, bool) - Проверка на работоспособность директории.
	\item void GetFiles(std::string, std::map<std::string, int>*) - Записывает все имена файлов директории в отдельное красно-чёрное дерево.
	\item void SaveBest(std::string, unsigned long long int, unsigned long long int) - При отсутствии ключей 1 и 9 выбирает наименьший из полученных компрессией файлов и удаляет наибольший.
	\item void ShowErrors(std::string) - Вывод сообщений о возникших ошибках во время подготовки данных для алгоритмов.
	\item void Mv(std::string, std::string) - Выполняет команду mv для переименования временного файла.
	\item void Rm(std::string) - Выполняет команду rm для удаления файла получившегося в процессе компрессии/декомпрессии и содержащего битые данные из-за ошибки алгоритма или удаляет поступивший алгоритму файл в случае отсутствия ключа k. 
		
\end{enumerate}

\subsection*{Исходный код}%TODOпоходу его будем вставлять как всё закончим

\subsection*{Тест производительности}%TODO это нормально затестить получится токо когда всё будет

\noindent
\begin{tabular}{| l | l | l | l | l | l | l |}
	\hline
	Файл             & Размер 	 & Алгоритм & Время  & Время        & Размер  & Коэффициент \\
	& исходного &          & сжатия & декомпрессии & сжатого & сжатия      \\
	& файла     &          & (с)    & (с)          & файла   &	   		    \\
	\hline
	world95.txt      & & LZ77       & & & &\\
	\hline
	enwik8           & & LZ77       & & & &\\
	\hline
	enwik9           & & LZ77       & & & &\\
	\hline
	world95.txt      & & Арифметика & & & &\\
	\hline
	enwik8           & & Арифметика & & & &\\
	\hline
	enwik9           & & Арифметика & & & &\\
	\hline
	world95.txt      & & gzip       & & & &\\
	\hline
	enwik8           & & gzip       & & & &\\
	\hline
	enwik9           & & gzip       & & & &\\
	\hline
	
	
\end{tabular}

%TODO ВВеди характеристики компа

\begin{itemize}
	\item Центральный процессор - 
	\item Графический адаптер - 
	\item Оперативная память - 
\end{itemize}

\subsection*{Выводы}

Благодаря выполнению данного проекта я научился основным принципам работы с файлами и директориями во время компрессии и декомпрессии. Так же я освоил основные правила и принципы работы компрессии и декомпрессии данных. Два построенных алгоритма дали мне необходимый базис навыков для работы с кастомными буферами. Так же я значительно улучшил свои навыки написания комплексных программ построения утилит, к примеру я научился реализовывать поддержку ключей и возможность работы нескольких алгоритмов.

Помимо этого стоит отметить, что статическое арифметическое кодирование будет проигрывать зачастую динамическому. Причина кроется в том, что в процессе чтения файла будут складываться ситуации, когда какой-то символ попадается достаточно часто, так что по сути его можно будет закодировать меньшим числом бит. Но если у нас статическое арифметическое кодирование, то возможна ситуация, когда под такой символ понадобится больше битов для кодирования, чем нужно. По сути динамический вариант может хорошо адаптироваться под какие-то временные особенности текста, что благоприятно влияет на качество, но взамен немного бьёт по времени работы.



\subsection*{Список литературы}
\begin{enumerate}
	\item Арифметическое кодирование - Arithmetic coding [Электронный ресурс]:\\ ru.qwe.wiki URL: https://ru.qwe.wiki/wiki/Arithmetic\_coding (дата обращения\\ 28.08.2020)
	\item Arithmetic Coding [Электронный ресурс]: users.cs.cf.ac.uk URL:\\ https://users.cs.cf.ac.uk/Dave.Marshall/Multimedia/node213.html (дата обращения 16.09.2020)
	\item LZ77 на C, реализация алгоритма LZ77 на C [Электронный ресурс]:\\ algor.skyparadise.org URL: https://algor.skyparadise.org/read/14 (дата обращения 16.09.2020)
\end{enumerate}
\end{document}