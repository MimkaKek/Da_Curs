\documentclass[12pt]{article}
\usepackage{indentfirst}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{listings}

\begin{document}
\begin{titlepage}
	\begin{center}
		\bfseries
		
		{\Large Московский авиационный институт\\ (национальный исследовательский университет)
			
		}
		
		\vspace{48pt}
		
		{\large Факультет информационных технологий и прикладной математики
		}
		
		\vspace{36pt}
		
		
		{\large Кафедра вычислительной математики и~программирования
			
		}
		
		
		\vspace{48pt}
		
		Курсовая работа по курсу <<Дискрeтный анализ>>: Методы сжатия данных
	\end{center}
	
	\vspace{72pt}
	
	\begin{flushright}
		\begin{tabular}{rl}
			Студент: & А.\,М. Титеев  \\
			Преподаватель: & Н.\,А. Зацепин \\
			Группа: & М8О-408Б \\
			Дата: & \\
			Оценка: & \\
			Подпись: & \\
		\end{tabular}
	\end{flushright}
	
	\vfill
	
	\begin{center}
		\bfseries
		Москва, \the\year
	\end{center}
\end{titlepage}

\pagebreak
\subsection*{Условие}

Необходимо реализовать два известных метода сжатия данных для сжатия одного файла. 

Формат запуска должен быть аналогичен формату запуска программы gzip, должны быть поддержаны следующие ключи: c, d, k, l, r, t, 1, 9. Должно поддерживаться указание символа дефиса в качестве стандартного ввода.

\subsection*{Метод решения}

Как и требуется в условии запуск программы аналогичен запуску утилиты gzip: ./main <ключи> <файлы> <ключи> <файлы> ...

\subsubsection*{Препроцессинг}

На первом этапе работы программа определяет наличие в поступившей строке ключей, директорий и файлов.
При обработке ключей учитывается их взаимоперекрываение, как в утилите gzip: l и r имеют наибольший приоритет, далее идёт ключ t, после чего остальные. В случае, если новый ключ перекрывает по логике утилиты некоторые из уже имеющихся, то эти ключи деактивируются.

Если полученное слово из стандартного ввода не является ключом, то программа проверяет наличие директории с таким именем. Если такой директории нет, то считается, что это имя файла, и оно заносится в список файлов. Если директория с таким именем существует и подключён ключ r, то все файлы внутри этой директории добавляются в список.

После с файлами ведётся работа согласно введённым ключам.

\subsubsection*{Арифметический алгоритм}

В этой программе реализованная целочисленная арифметика. Причина проста - машинам лучше и проще работать с целыми числами, чем с числами с плавающими точками. Например, наличие машинного эпсилон.

Перед объяснением алгоритма стоит упомянуть ряд моментов. Во-первых, так как мы имеем дело с целыми числами, это значит, что у нас нет возможности бесконечно переходить к меньшим отрезкам. Поэтому в данной реализации работа с отрезками сводится к их масштабированию, параллельно записывая нужные биты. Во-вторых, для работы внутри рассматриваемого отрезка используется таблица частот, которая содержит в себе информацию о том, насколько часто встречается тот или иной символ. Это необходимо для нужного разбиения на ещё более мелкие отрезки.

Данная реализация делится на несколько фаз:
\begin{itemize}
	\item Подготовительная фаза - производится инициализация буфера, куда будут записываться биты, счётчиков, начального отрезка и таблицы частот. Отдельно стоит упомянуть, что начальные значения частот у каждого символа изначально стоят как единицы. Это необходимо корректной работы с отрезком. Помимо этого также в файл заносится служебная информация, где указано, каким алгоритмом сжали и какой был размер исходного файла.
	\item Основная фаза - производится кодировка символов. Каждому символу в начале сопоставляется соответствующий маленький отрезок, с которым в дальнейшем происходит масштабирование и смещение, дабы избежать переполнения. В процессе заносятся соответствующие биты. После того, как дальнейшее масштабирование становится невозможным, кодировка символа завершается. Обновляется таблица частот в соответствии с символом.
	\item Завершающая фаза - когда символы закодированы, программа кодирует EOF и дозаписывает недостающие биты. На этом работа с файлом завершается.
\end{itemize}

В процессе декомпрессии алгоритм будет часто обращаться к таблице частот, поэтому надо максимально сильно сократить работу с ней, чтобы алгоритм не просел по времени. Для этого есть довольно простое решение - в процессе декомпрессии во время обновления таблицы будет производиться её небольшая сортировка. Сортировка сводится к тому, чтобы часто попадающиеся символы были ближе к началу таблицы. Это и ускоряет декомпрессию.

Аналогично компрессии, декомпрессию можно разделить на несколько фаз:
\begin{itemize}
	\item Подготовительная фаза - почти аналогично компрессии, но с некоторыми отличиями. Инициализируется специальная переменная, которая будет содержать в себе биты, которые были в сжатом файле. Также в файл ничего не записывается, а производится лишь чтение.
	\item Основная фаза - при помощи специальной переменной определяем символ. Проводим такие же манипуляции с отрезком, как и в сжатии, параллельно загружая новые биты из файла и отбрасывая уже лишние. После этого аналогично компрессии обновляется таблица частот.
	\item Завершающая фаза - после получения кода об EOF декомпрессия завершается. Весь результат декомпрессии по ходу заносится в новый файл.
\end{itemize}

\subsubsection*{LZ77 компрессия}
LZ77 использует уже просмотренную часть сообщения как словарь. Чтобы добиться сжатия, он пытается заменить очередной фрагмент сообщения на указатель в содержимое словаря.

В качестве модели данных LZ77 использует “скользящее” по сообщению окно, разделенное на две неравные части. Первая, большая по размеру, включает уже просмотренную часть сообщения и называется словарём. Вторая, намного меньшая, является буфером, содержащим еще не закодированные символы входного потока. Обычно размер окна составляет несколько килобайтов. Буфер намного меньше, обычно не более ста байтов. Алгоритм пытается найти в словаре фрагмент, совпадающий с содержимым буфера.

Алгоритм LZ77 выдает набор бит, в котором закодировано три элемента:<offset,length,symbol>
\begin{enumerate}
    \item offset - смещение в словаре относительно текущего положения, до совпадающей подстроки;
    \item length - длина подстроки;
    \item symbol - первый символ в буфере, следующий за подстрокой.
\end{enumerate}
Если совпадение не было найдено, то алгоритм просто выдаст код <0, 0, первый символ в буфере> и продолжит работать, однако такое решение неэффективно, хоть и гарантирует, что алгоритм сможет закодировать любое сообщение.
Можно улучшить алгоритм для подобных слчаев, если вместо кодирования набором бит <offset,length,symbol> кодировать либо <offset,length>, либо <symbol>.Такая версия алгоритма называется LZS и тратит на одиночные символы гораздо меньше бит.
Также для ускорения сжатия при поиске совпадений в словаре использовалась хэш таблица и словарь был представлен циклицеским буфером.
\subsubsection*{LZ77 декомпрессия}
В стандартной версии LZ77 мы считывем количество бит, которым кодируется <offset,length,symbol>, после чего находим нужную позицию в тексте с помощью offset и копируем посимвольно length байтов, после чего пишем символ symbol.
В LZS сначала считывается один бит, который определяет, закодирована ли пара <offset,length> или <symbol>. Если это символ, то считывается 8 битов которые и являются раскодированным символом. Иначе, если это не закодированный конец файла, считываются сначала биты длины, затем сдвига, после чего происходит раскодировка и соответствующее количество символов словаря помещается в окно.

\subsection*{Описание файлов программы}

Код программы разбит на 9 файлов:

\begin{enumerate}
	\item Arithmetic.h - Описывает класс Arithmetic, в котором заключён соответствующий алгоритм кодирования. 
	\item Arithmetic.cpp - Реализует класс Arithmetic.
	\item Globals.h - Файл с общими библиотеками.
	\item LZ77.h - Описывает класс LZ77, в котором заключён соответствующий алгоритм кодирования.
	\item LZ77.cpp - Реализует класс LZ77.
	\item main.cpp - Основной файл, отвечающий за чтение входных данных и принятие действий относительно каждого файла.
	\item Makefile - Файл для сборки программы.
	\item preprocessing.h - Содержит прототипы функций, необходимых для обработки данных перед компрессией/декомпрессией.
	\item preprocessing.cpp - Реализует все функции из соответствующей библиотеки.
\end{enumerate}

\subsection*{Основные типы данных}

\begin{enumerate}
	\item Arithmetic - Реализует соответствующий алгоритм.
	\item LZ77 - Реализует соответствующий алгоритм.
\end{enumerate}

\subsection*{Описание методов и функций программы}
 
\subsubsection*{Основные свойства и методы класса Arithmetic}
\noindent
public:

\begin{enumerate}
	\item bool Compress (const char*, const char*) - сжатие файла.
	\item bool Decompress (const char*, const char*) - распаковка файла.
	\item Arithmetic() - конструктор, в котором задаются начальные значения для последующей работы со сжатием/распаковкой файла.
\end{enumerate}
\noindent
private:

\begin{enumerate}
	\item bool chError - флаг ошибки при распаковке файла.
	\item unsigned char indexToChar [NO\_OF\_SYMBOLS] - таблица перевода из индексов к символам.
	\item int charToIndex [NO\_OF\_CHARS] - таблица перевода из символов в индексы.
	\item int cumFreq [NO\_OF\_SYMBOLS + 1] - массив накопленных частот. Нужен для определения границ.
	\item int freq [NO\_OF\_SYMBOLS + 1] - массив частот. В нём хранится число появлений тех или иных символов.
	\item long low - нижняя граница отрезка. 
	\item long high - верхняя граница отрезка.
	\item long value - число, которое лежит в отрезке.
	\item long bitsToFollow - количество бит, которые надо пустить в след за следующим выставляемым битом.
	\item int buffer - буффер для работы с файлом.
	\item int bitsToGo - число битов, которые ещё можно загрузить в буфер.
	\item int garbageBits - счётчик плохих битов при распаковке файла. Как только их становится слишком много - распаковка отменяется и выводится сообщение об этом.
	\item FILE *out - файл, в который мы записываем.
	\item FILE *in - файл, из которого мы считываем.
	\item void UpdateModel (int) - обновление модели под новый символ.
	\item void StartInputingBits() - подготовка к побитовому вводу.
	\item void StartOutputingBits() - подготовка к побитовому выводу.
	\item void EncodeSymbol (int) - кодировка символа.
	\item void StartEncoding() - подготовка к сжатию.
	\item void DoneEncoding() - завершение кодирования. Загрузка последних битов в буфер.
	\item void StartDecoding() - подготовка к распаковке.
	\item int DecodeSymbol() - распаковка символа.
	\item int InputBit() - получение одного бита из файла.
	\item void OutputBit(int) - отправление одного бита в файл.
	\item void DoneOutputingBits() - отправление последних битов в файл.
	\item void OutputBitPlusFollow(int) - вывод указанного бита и отложенных ранее.
\end{enumerate}

\subsubsection*{Основные свойства и методы класса TLZ77}
\noindent
public:

\begin{enumerate}
    \item LZ77() - стандартный конструктор
    \item IStruct - вспомогательная структура, которая нужна только для удобной конструкции класса
    \item LZ77(IStruct s) - конструктор через вспомогательную структуру IStruct
	\item InitEncode() - инициализирует данные необходимые для сжатия
	\item Compress(std::string in\_str, std::string out\_str) - сжатие файла 
	\item Decompress(std::string in\_str, std::string out\_str) -  распаковка файла
	\item ~LZ77() - деструктор
\end{enumerate}
\noindent
private:

\begin{enumerate}
	\item LoadDict(unsigned int dictpos) - загрузка словаря из файла в циклический буфер на позиции dictpos
	\item DeleteData(unsigned int dictpos) - удаления всех ссылок на удаляемый сектор с началом в dictpos
	\item HashData(unsigned int dictpos, unsigned int bytestodo) - хэширование и запись ссылок на возможное преведущее совпадение в словаре
	\item FindMatch(unsigned int dictpos, unsigned int startlen) - поиск максимального совпадения в словаре с позицией dictpos, не меньше чем startlen 
	\item DictSearch(unsigned int dictpos, unsigned int bytestodo) - кодирование считаного сектора с началом в dictpos и длинной bytestodo 
	\item PutChar(unsigned int character) - кодирование символа character
	\item PutMatch(unsigned int matchlen, unsigned int matchdistance) - кодирование пары <matchlen, matchdistance>
	\item GetBits(unsigned int numbits) - считывание numbits битов из файла
	\item PutBits(unsigned int bits, unsigned int numbits) - отправка numbits битов записанных в bits в файл
    \item const int threshold\_c - минимальное совпадение, для записи в виде<length,offset>
	\item const int maxCompares\_c   - максимальное число раз которое ищется совпадение в FindMatch
	\item const int charBits\_c	  - сколькими битами кодируется символ		
	\item const int lengthBits\_c  	  - сколькими битами кодируется длина совпадения		 
	\item const int dictBits\_c 	  - сколькими битами кодируется длина словаря(offset) 		
	\item const int hashBits\_c 	  - сколько бит в хэше
	\item const int sectorBits\_c 	  - сколько бит в секторе		
	\item const unsigned int maxMatch\_c - максимальная кодируемая длина совпадения
	\item const unsigned int dictSize\_c - размер словаря
	\item const unsigned int hashSize\_c - размер хэша
	\item const unsigned int shiftBits\_c	- на сколько происходит сдвиг при хэшировании
	\item const unsigned int sectorSize\_c	- размер сектора
	\item const unsigned int sectorAND\_c	- нужен для определения к какому сектору относится то или иное место в словаре
	\item unsigned char* dict - ссылка на словарь размером dictSize\_c
	\item unsigned int *hash - ссылка на хэш размером hashSize\_c
	\item unsigned int *nextlink - ссылка на массив, на каждой позиции которого хранится позиция преведущего вхождения подстроки с совпадающим хэшем
	\item unsigned int matchlength - длина совпадения, применяется в FindMatch, DictSearch
	\item unsigned int	matchpos - позиция совпдения, применяется там же
	\item unsigned int	bitbuf - буфер, который испольуется для записи и чтения бит из файла
	\item unsigned int	bitsin - сколько битов находится в буфере в данный момент
	\item unsigned int	masks[17] - маски для побитного чтения/записи
    \item FILE *infile, *outfile; - файлы из которых идёт считывание/запись
\end{enumerate}

\subsubsection*{Прочие функции} 
\noindent
\begin{enumerate}
	\item void Compress(std::string) - Создает необходимые для компрессии данные (временные файлы).
	\item void Decompress(std::string) - Создает необходимые для декомпрессии данные (классы и временные файлы).
	\item bool ActivateKeys(std::string) - Активирует или деактивирует указанные в аргументах ключи. Из-за некорректного ключа функция возвращает false и завершает работу программы. 
	\item void ArchiveInfo(std::string) - Выводит информацию об архиве.
	\item unsigned long long int CompressA(std::string) - Создаёт класс для арифметического кодирования и работает с ним. При некорректной работе алгоритма возвращает 0, иначе количество байт в получившемся файле.
	\item unsigned long long int CompressL(std::string) - Создаёт класс для кодирования LZ77 и работает с ним. При некорректной работе алгоритма возвращает 0, иначе количество байт в получившемся файле.
	\item bool ArchiveCheck(std::string) - Проверка на наличие у файла суффикса <<.gz>>.
	\item bool DirectoryCheck(std::string, bool) - Проверка на работоспособность директории.
	\item void GetFiles(std::string, std::map<std::string, int>*) - Записывает все имена файлов директории в отдельное красно-чёрное дерево.
	\item void SaveBest(std::string, unsigned long long int, unsigned long long int) - При отсутствии ключей 1 и 9 выбирает наименьший из полученных компрессией файлов и удаляет наибольший.
	\item void ShowErrors(std::string) - Вывод сообщений о возникших ошибках во время подготовки данных для алгоритмов.
	\item void Mv(std::string, std::string) - Выполняет команду mv для переименования временного файла.
	\item void Rm(std::string) - Выполняет команду rm для удаления файла получившегося в процессе компрессии/декомпрессии и содержащего битые данные из-за ошибки алгоритма или удаляет поступивший алгоритму файл в случае отсутствия ключа k. 
		
\end{enumerate}

\subsection*{Исходный код}%TODOпоходу его будем вставлять как всё закончим

\subsection*{Тест производительности}%TODO это нормально затестить получится токо когда всё будет

\noindent
\begin{tabular}{| l | l | l | l | l | l | l |}
	\hline
	Файл             & Размер 	 & Алгоритм & Время  & Время        & Размер  & Коэффициент \\
	& исходного &          & сжатия & декомпрессии & сжатого & сжатия      \\
	& файла     &          & (с)    & (с)          & файла   &	   		    \\
	\hline
	world95.txt      & & LZ77       & & & &\\
	\hline
	enwik8           & & LZ77       & & & &\\
	\hline
	enwik9           & & LZ77       & & & &\\
	\hline
	world95.txt      & & Арифметика & & & &\\
	\hline
	enwik8           & & Арифметика & & & &\\
	\hline
	enwik9           & & Арифметика & & & &\\
	\hline
	world95.txt      & & gzip       & & & &\\
	\hline
	enwik8           & & gzip       & & & &\\
	\hline
	enwik9           & & gzip       & & & &\\
	\hline
	
	
\end{tabular}

%TODO ВВеди характеристики компа

\begin{itemize}
	\item Центральный процессор - 
	\item Графический адаптер - 
	\item Оперативная память - 
\end{itemize}

\subsection*{Выводы}

Благодаря выполнению данного проекта я научился основным принципам работы с файлами и директориями во время компрессии и декомпрессии. Так же я освоил основные правила и принципы работы компрессии и декомпрессии данных. Два построенных алгоритма дали мне необходимый базис навыков для работы с кастомными буферами. Так же я значительно улучшил свои навыки написания комплексных программ построения утилит, к примеру я научился реализовывать поддержку ключей и возможность работы нескольких алгоритмов.

Помимо этого стоит отметить, что статическое арифметическое кодирование будет проигрывать зачастую динамическому. Причина кроется в том, что в процессе чтения файла будут складываться ситуации, когда какой-то символ попадается достаточно часто, так что по сути его можно будет закодировать меньшим числом бит. Но если у нас статическое арифметическое кодирование, то возможна ситуация, когда под такой символ понадобится больше битов для кодирования, чем нужно. По сути динамический вариант может хорошо адаптироваться под какие-то временные особенности текста, что благоприятно влияет на качество, но взамен немного бьёт по времени работы.



\subsection*{Список литературы}
\begin{enumerate}
	\item Арифметическое кодирование - Arithmetic coding [Электронный ресурс]:\\ ru.qwe.wiki URL: https://ru.qwe.wiki/wiki/Arithmetic\_coding (дата обращения\\ 28.08.2020)
	\item Arithmetic Coding [Электронный ресурс]: users.cs.cf.ac.uk URL:\\ https://users.cs.cf.ac.uk/Dave.Marshall/Multimedia/node213.html (дата обращения 16.09.2020)
	\item LZ77 на C, реализация алгоритма LZ77 на C [Электронный ресурс]:\\ algor.skyparadise.org URL: https://algor.skyparadise.org/read/14 (дата обращения 16.09.2020)
\end{enumerate}
\end{document}
